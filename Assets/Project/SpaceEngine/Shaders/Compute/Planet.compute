/* Procedural planet generator.
 *
 * Copyright (C) 2015-2016 Denis Ovchinnikov
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#define nVerticesPerSide 				quadGenerationConstants[0].meshSettings.x
#define nVerticesPerSideWithBorder 		quadGenerationConstants[0].meshSettings.y
#define nVerticesPerSideSub 			quadGenerationConstants[0].meshSettings.z
#define nVerticesPerSideWithBorderSub 	quadGenerationConstants[0].meshSettings.w
#define borderModMesh					quadGenerationConstants[0].borderMod.x
#define borderModTexture				quadGenerationConstants[0].borderMod.y

//#define defaultNoise

#include "UnityCG.cginc"
#include "Assets/Project/SpaceEngine/Shaders/Compute/Utils.cginc"
#include "Assets/Project/SpaceEngine/Shaders/TCCommon.cginc"

RWTexture2D<float4> Height;
RWTexture2D<float4> Normal;

StructuredBuffer<QuadGenerationConstants> quadGenerationConstants;

RWStructuredBuffer<OutputStruct> patchPreOutput;
RWStructuredBuffer<OutputStruct> patchOutput;
RWStructuredBuffer<OutputStruct> patchPreOutputSub;

RWStructuredBuffer<QuadCorners> quadCorners;

float3 ScaledCoordinate(float3 coord)
{
	return normalize(coord);
}

float NoiseFunction(float3 coord, float lodom)
{
	float3 scaledCoord = ScaledCoordinate(coord);
	
	#ifdef defaultNoise
	float noise = RidgedMultifractalEroded(scaledCoord * 2 + Randomize, 1, 1, 4) * 2;	
	#else
	//float noise = HeightMapAsteroid(scaledCoord);
	//float noise = HeightMapTerra(scaledCoord);
	float noise = HeightMapPlanet(scaledCoord, lodom);
	//float noise = HeightMapCloudsGasGiant(scaledCoord);
	#endif

	float normalized = (noise + 1.0) * 0.5;

	return normalized;
}

float4 ColorFunction(float3 coord, float height, float slope)
{
	float3 scaledCoord = ScaledCoordinate(coord);

	#ifdef defaultNoise
	float4 color = float4(height, height, height, slope);
	#else
	//float4 colorMapColor = ColorMapAsteroid(scaledCoord, height, slope);
	//float4 glowMapColor = GlowMapAsteroid(scaledCoord, height, slope);
	//float4 color = colorMapColor + glowMapColor;
	//float4 color = ColorMapTerra(scaledCoord, height, slope);
	float4 color = ColorMapPlanet(scaledCoord, height, slope);
	//float4 color = ColorMapCloudsGasGiant(scaledCoord, height, slope);
	//float4 color = float4(height, height, height, 1);
	#endif
	
	return color;
}

#pragma kernel HeightMain
[numthreads(32, 32, 1)]
void HeightMain (uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int outBuffOffset = id.x + id.y * nVerticesPerSideWithBorder;

	float3 cubeCoord = CubeCoord(constants, nVerticesPerSideWithBorder, id, borderModMesh, constants.spacing);

	float3 patchCenter = normalize(constants.patchCubeCenter) * constants.planetRadius;
	float3 patchNormalizedCoord = normalize(cubeCoord);

	float3 patchCoord =  constants.planetRadius * patchNormalizedCoord;
	float3 patchCoordCentered = patchCoord - patchCenter;
	float3 patchCubeCoordCentered = patchNormalizedCoord;
	float3 patchCubeCoordCenteredFlat = patchNormalizedCoord;

	float noise = NoiseFunction(patchCoord, constants.lodOctaveModifier);

	float height = noise * constants.terrainMaxHeight;

	patchCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCenteredFlat += patchNormalizedCoord;
	
	float4 output = float4(patchCoordCentered.xyz, 0.0);
	float4 cubeOutput = float4(patchCubeCoordCentered.xyz, 0.0);

	patchPreOutput[outBuffOffset].noise = noise;
	patchPreOutput[outBuffOffset].patchCenter = patchCenter;
	patchPreOutput[outBuffOffset].position = output;
	patchPreOutput[outBuffOffset].cubePosition = cubeOutput;
}

#pragma kernel HeightSub
[numthreads(32, 32, 1)]
void HeightSub(uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int outBuffOffset = id.x + id.y * nVerticesPerSideWithBorderSub;

	float3 cubeCoord = CubeCoord(constants, nVerticesPerSideWithBorderSub, id, borderModTexture, constants.spacingsub);

	float3 patchCenter = normalize(constants.patchCubeCenter) * constants.planetRadius;
	float3 patchNormalizedCoord = normalize(cubeCoord);

	float3 patchCoord =  constants.planetRadius * patchNormalizedCoord;
	float3 patchCoordCentered = patchCoord - patchCenter;
	float3 patchCubeCoordCentered = patchNormalizedCoord;
	float3 patchCubeCoordCenteredFlat = patchNormalizedCoord;
	
	float noise = NoiseFunction(patchCoord, constants.lodOctaveModifier);

	float height = noise * constants.terrainMaxHeight;

	patchCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCenteredFlat += patchNormalizedCoord;
	
	float4 output = float4(patchCoordCentered.xyz, 0.0);
	float4 cubeOutput = float4(patchCubeCoordCentered.xyz, 0.0);

	patchPreOutputSub[outBuffOffset].noise = noise;
	patchPreOutputSub[outBuffOffset].patchCenter = patchCenter;
	patchPreOutputSub[outBuffOffset].position = output;
	patchPreOutputSub[outBuffOffset].cubePosition = cubeOutput;
}

#pragma kernel TexturesSub
[numthreads(30, 30, 1)]
void TexturesSub(uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int inBuffOffset = (id.x + 1) + (id.y + 1) * nVerticesPerSideWithBorderSub;
	int outBuffOffset = id.x + id.y * nVerticesPerSideSub;
	
	float noise = patchPreOutputSub[inBuffOffset].noise;
	float3 patchCenter = patchPreOutputSub[inBuffOffset].patchCenter;
	float4 position = patchPreOutputSub[inBuffOffset].position;
	float4 cubePosition = patchPreOutputSub[inBuffOffset].cubePosition;

	float slope = 0;
	float3 sobelNormal = GetSobelNormal(constants, patchPreOutputSub, nVerticesPerSideWithBorderSub, id);
	float3 heightNormal = GetHeightNormal(constants, patchPreOutputSub, nVerticesPerSideWithBorderSub, id, slope);
	float3 positionNormal = GetHeightNormalFromPosition(constants, patchPreOutputSub, nVerticesPerSideWithBorderSub, id);

	float3 normal = positionNormal;

	float4 color = ColorFunction(cubePosition.xyz, noise, slope);
	float4 normalColor = float4(normal, slope);
	float4 heightColor = float4(color.xyz, noise);

	Normal[id.yx] = normalColor;
	Height[id.yx] = heightColor;
}

#pragma kernel Transfer
[numthreads(30, 30, 1)]
void Transfer(uint3 id : SV_DispatchThreadID)
{
	int inBuffOffset = (id.x + 1) + (id.y + 1) * nVerticesPerSideWithBorder;
	int outBuffOffset = id.x + id.y * nVerticesPerSide;

	patchOutput[outBuffOffset] = patchPreOutput[inBuffOffset];
}

#pragma kernel GetCorners
[numthreads(1, 1, 1)]
void GetCorners(uint3 id : SV_DispatchThreadID)
{
	float4 center = float4(patchOutput[0 + 0 * nVerticesPerSide].patchCenter, 0);

	float size = nVerticesPerSide - 1;

	float4 topLeftCorner = patchOutput[size + 0 * nVerticesPerSide].position + center;
	float4 topRightCorner = patchOutput[0 + 0 * nVerticesPerSide].position + center;
	float4 bottomLeftCorner = patchOutput[size + size * nVerticesPerSide].position + center;
	float4 bottomRightCorner = patchOutput[0 + size * nVerticesPerSide].position + center;

	quadCorners[id.x + id.y].topLeftCorner = topLeftCorner;
	quadCorners[id.x + id.y].topRightCorner = topRightCorner;
	quadCorners[id.x + id.y].bottomLeftCorner = bottomLeftCorner;
	quadCorners[id.x + id.y].bottomRightCorner = bottomRightCorner;
}