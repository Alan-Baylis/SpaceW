/* Procedural planet generator.
 *
 * Copyright (C) 2015-2016 Denis Ovchinnikov
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#define nVerticesPerSide 120
#define nVerticesPerSideWithBorder 128
#define nVerticesPerSideSub 240
#define nVerticesPerSideWithBorderSub 256

//#define defaultNoise

#include "UnityCG.cginc"
#include "Assets/Project/SpaceEngine/Shaders/Compute/Utils.cginc"
#include "Assets/Project/SpaceEngine/Shaders/TCCommon.cginc"

RWTexture2D<float4> Height;
RWTexture2D<float4> Normal;

RWStructuredBuffer<QuadGenerationConstants> quadGenerationConstants;

RWStructuredBuffer<OutputStruct> patchPreOutput;
RWStructuredBuffer<OutputStruct> patchOutput;
RWStructuredBuffer<OutputStruct> patchPreOutputSub;

float3 ScaledCoordinate(float3 coord)
{
	return 0.00005 * coord;
}

float NoiseFunction(float3 coord)
{
	float3 scaledCoord = ScaledCoordinate(coord);
	
	#ifdef defaultNoise
	float noise = RidgedMultifractalEroded(scaledCoord * 2 + Randomize, 1, 1, 4) * 2;
	#else
	//float noise = HeightMapAsteroid(scaledCoord);
	//float noise = HeightMapTerra(scaledCoord);
	float noise = HeightMapPlanet(scaledCoord);
	#endif

	//float normalized = (noise + 1.0) / 2;

	return noise;
}

float4 ColorFunction(float3 pos, float3 coord, float height, float slope)
{
	float3 scaledCoord = ScaledCoordinate(coord);

	#ifdef defaultNoise
	float4 color = float4(height / 2, height / 2, height / 2, slope);
	#else
	//float4 colorMapColor = ColorMapAsteroid(scaledCoord, height, slope);
	//float4 glowMapColor = GlowMapAsteroid(scaledCoord, height, slope);
	//float4 color = colorMapColor + glowMapColor;
	//float4 color = ColorMapTerra(scaledCoord, height, slope);
	float4 color = ColorMapPlanet(pos, scaledCoord, height, slope);
	//float4 color = float4(height, height, height, 1);
	#endif
	
	return color;
}

float3 GetSobelNormal(QuadGenerationConstants constants, RWStructuredBuffer<OutputStruct> buffer, int size, uint3 id)
{
	float normalStrength = 0.5 / ((constants.lodLevel / 20.0 + 1.0) * (constants.lodLevel / 20.0 + 1.0));
	
	float tl = buffer[(id.x + 0) + (id.y + 0) * size].noise * constants.lodLevel;
	float  l = buffer[(id.x + 0) + (id.y + 1) * size].noise * constants.lodLevel;
	float bl = buffer[(id.x + 0) + (id.y + 2) * size].noise * constants.lodLevel;
	float  t = buffer[(id.x + 1) + (id.y + 0) * size].noise * constants.lodLevel;
	float  b = buffer[(id.x + 1) + (id.y + 2) * size].noise * constants.lodLevel;
	float tr = buffer[(id.x + 2) + (id.y + 0) * size].noise * constants.lodLevel;
	float  r = buffer[(id.x + 2) + (id.y + 1) * size].noise * constants.lodLevel;
	float br = buffer[(id.x + 2) + (id.y + 2) * size].noise * constants.lodLevel;

	float xdelta = tr + 2.0 * r + br - tl - 2.0 * l - bl;
	float ydelta = bl + 2.0 * b + br - tl - 2.0 * t - tr;

	float3 normal = normalize(float3(xdelta, ydelta, 2.0 * 1));

	return normal;
}

float3 GetHeightNormal(QuadGenerationConstants constants, RWStructuredBuffer<OutputStruct> buffer, int size, uint3 id, out float slope)
{
	float left  = buffer[(id.x + 0) + (id.y + 1) * size].noise * constants.lodLevel;
	float right = buffer[(id.x + 2) + (id.y + 1) * size].noise * constants.lodLevel;
	float up    = buffer[(id.x + 1) + (id.y + 0) * size].noise * constants.lodLevel;
	float down  = buffer[(id.x + 1) + (id.y + 2) * size].noise * constants.lodLevel;

	float xdelta = ((left - right) + 1.0) * 0.5;
	float ydelta = ((up - down) + 1.0) * 0.5;
	float zdelta = ((right - left) + 1.0) * 0.5;
	float wdelta = ((up - down) + 1.0) * 0.5;

	float3 xnormal = float3(xdelta, ydelta, 1.0);
	float3 ynormal = float3(ydelta, xdelta, 1.0);
	float3 znormal = float3(zdelta, wdelta, 1.0);
	float3 wnormal = float3(wdelta, zdelta, 1.0);

	float xslope = 0.5 / max(dot(xnormal, float3(0.0, 1.0, 0.0)), 0.001);
	float yslope = 0.5 / max(dot(ynormal, float3(0.0, 1.0, 0.0)), 0.001);
	float zslope = 0.5 / max(dot(znormal, float3(0.0, 1.0, 0.0)), 0.001);
	float wslope = 0.5 / max(dot(wnormal, float3(0.0, 1.0, 0.0)), 0.001);

	float finalSlope = min(min(xslope, yslope), min(zslope, wslope));
	
	slope = finalSlope;

	return xnormal;
}

float3 GetHeightNormalFromPosition(QuadGenerationConstants constants, RWStructuredBuffer<OutputStruct> buffer, int size, uint3 id)
{
	float3 left	 = (buffer[(id.x + 0) + (id.y + 1) * size].pos.xyz);// * constants.lodLevel;
	float3 right = (buffer[(id.x + 2) + (id.y + 1) * size].pos.xyz);// * constants.lodLevel;
	float3 up	 = (buffer[(id.x + 1) + (id.y + 0) * size].pos.xyz);// * constants.lodLevel;
	float3 down  = (buffer[(id.x + 1) + (id.y + 2) * size].pos.xyz);// * constants.lodLevel;
	float3 curr	 = (buffer[(id.x + 1) + (id.y + 1) * size].pos.xyz);// * constants.lodLevel;
	
	float3 e0 = curr - left;
	float3 e1 = curr - right;
	float3 e2 = curr - up;
	float3 e3 = curr - down;

	float3 n0 = cross(e0, e2);
	float3 n1 = cross(e1, e3);

	float3 n = normalize(n0 + n1);

	return -n;
}

#pragma kernel HeightMain
[numthreads(32, 32, 1)]
void HeightMain (uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int outBuffOffset = id.x + id.y * nVerticesPerSideWithBorder;

	float3 cubeCoord = CubeCoord(constants, nVerticesPerSideWithBorder, id, 7, constants.spacing);

	float3 patchCenter = normalize(constants.patchCubeCenter) * constants.planetRadius;
	float3 patchNormalizedCoord = normalize(cubeCoord);

	float3 patchCoord =  constants.planetRadius * patchNormalizedCoord;
	float3 patchCoordCentered = patchCoord - patchCenter;
	float3 patchCubeCoordCentered = patchNormalizedCoord;
	float3 patchCubeCoordCenteredFlat = patchNormalizedCoord;

	float noise = NoiseFunction(patchCoord);

	float height = noise * constants.terrainMaxHeight;

	patchCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCenteredFlat += patchNormalizedCoord;
	
	float4 output = float4(patchCoordCentered.xyz, 0.0);
	float4 cubeOutput = float4(patchCubeCoordCentered.xyz, 0.0);

	patchPreOutput[outBuffOffset].noise = noise;
	patchPreOutput[outBuffOffset].patchCenter = patchCenter;
	patchPreOutput[outBuffOffset].vcolor = float4(patchCubeCoordCenteredFlat, 0);
	patchPreOutput[outBuffOffset].pos = output;
	patchPreOutput[outBuffOffset].cpos = cubeOutput;
}

#pragma kernel HeightSub
[numthreads(32, 32, 1)]
void HeightSub(uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int outBuffOffset = id.x + id.y * nVerticesPerSideWithBorderSub;

	float3 cubeCoord = CubeCoord(constants, nVerticesPerSideWithBorderSub, id, 17, constants.spacingsub);

	float3 patchCenter = normalize(constants.patchCubeCenter) * constants.planetRadius;
	float3 patchNormalizedCoord = normalize(cubeCoord);

	float3 patchCoord =  constants.planetRadius * patchNormalizedCoord;
	float3 patchCoordCentered = patchCoord - patchCenter;
	float3 patchCubeCoordCentered = patchNormalizedCoord;
	float3 patchCubeCoordCenteredFlat = patchNormalizedCoord;
	
	float noise = NoiseFunction(patchCoord);

	float height = noise * constants.terrainMaxHeight;

	patchCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCenteredFlat += patchNormalizedCoord;
	
	float4 output = float4(patchCoordCentered.xyz, 0.0);
	float4 cubeOutput = float4(patchCubeCoordCentered.xyz, 0.0);

	patchPreOutputSub[outBuffOffset].noise = noise;
	patchPreOutputSub[outBuffOffset].patchCenter = patchCenter;
	patchPreOutputSub[outBuffOffset].vcolor = float4(patchCubeCoordCenteredFlat, 0);
	patchPreOutputSub[outBuffOffset].pos = output;
	patchPreOutputSub[outBuffOffset].cpos = cubeOutput;
}

#pragma kernel TexturesSub
[numthreads(30, 30, 1)]
void TexturesSub(uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int inBuffOffset = (id.x + 1) + (id.y + 1) * nVerticesPerSideWithBorderSub;
	int outBuffOffset = id.x + id.y * nVerticesPerSideSub;
	
	float noise = patchPreOutputSub[inBuffOffset].noise;
	float3 patchCenter = patchPreOutputSub[inBuffOffset].patchCenter;
	float4 pos = patchPreOutputSub[inBuffOffset].pos;
	float4 cpos = patchPreOutputSub[inBuffOffset].cpos;

	float slope = 0;
	float3 sobelNormal = GetSobelNormal(constants, patchPreOutputSub, nVerticesPerSideWithBorderSub, id);
	float3 heightNormal = GetHeightNormal(constants, patchPreOutputSub, nVerticesPerSideWithBorderSub, id, slope);
	float3 positionNormal = GetHeightNormalFromPosition(constants, patchPreOutputSub, nVerticesPerSideWithBorderSub, id);

	float3 normal = positionNormal;

	float4 color = ColorFunction(pos.xyz, cpos.xyz, noise, slope);
	float4 normalColor = float4(normal, slope);
	float4 heightColor = float4(color.xyz, noise);

	Normal[id.yx] = normalColor;
	Height[id.yx] = heightColor;
}

#pragma kernel Transfer
[numthreads(30, 30, 1)]
void Transfer(uint3 id : SV_DispatchThreadID)
{
	int inBuffOffset = (id.x + 1) + (id.y + 1) * nVerticesPerSideWithBorder;
	int outBuffOffset = id.x + id.y * nVerticesPerSide;

	patchOutput[outBuffOffset] = patchPreOutput[inBuffOffset];
}

#pragma kernel GetCorners
[numthreads(30, 30, 1)]
void GetCorners(uint3 id : SV_DispatchThreadID)
{

}