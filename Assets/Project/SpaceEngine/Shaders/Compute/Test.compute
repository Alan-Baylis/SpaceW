#define threadsPerGroup_X 32
#define threadsPerGroup_Y 32

#define nVerticesPerSide 60
#define nVertsPerSideWithBorder 64
#define nVerticesPerSideSub 240
#define nVertsPerSideWithBorderSub 256

#define defaultNoise

#include "Assets/Project/SpaceEngine/Shaders/TCCommonAsteroid.cginc"

struct QuadGenerationConstants
{
    float planetRadius;
	float spacing;
	float spacingreal;
	float spacingsub;
    float terrainMaxHeight;
	float lodLevel;
	float orientation;

    float3 cubeFaceEastDirection;
    float3 cubeFaceNorthDirection;
    float3 patchCubeCenter;
};

struct OutputStruct
{
	float noise;

	float3 patchCenter;

	float4 vcolor;
    float4 pos;
	float4 cpos;
};

RWTexture2D<float4> Height;
RWTexture2D<float4> Normal;

RWStructuredBuffer<QuadGenerationConstants> quadGenerationConstants;

RWStructuredBuffer<OutputStruct> patchPreOutput;
RWStructuredBuffer<OutputStruct> patchOutput;
RWStructuredBuffer<OutputStruct> patchPreOutputSub;

float3 FindBiTangent(float3 normal, float epsilon, float3 dir)
{
	float refVectorSign = sign(1.0 - abs(normal.x) - epsilon);

	float3 refVector = refVectorSign * dir;
	float3 biTangent = refVectorSign * cross(normal, refVector);

	return biTangent;
}

float3 FindTangent(float3 normal, float epsilon)
{
	float refVectorSign = sign(1.0 - abs(normal.x) - epsilon);

	float3 refVector = refVectorSign * float3(0.0, 1.0, 0.0);
	float3 biTangent = refVectorSign * cross(normal, refVector);

	return cross(-normal, biTangent);
}

float3 FindTangent(float3 normal, float epsilon, float3 dir)
{
	float refVectorSign = sign(1.0 - abs(normal.x) - epsilon);

	float3 refVector = refVectorSign * dir;
	float3 biTangent = refVectorSign * cross(normal, refVector);

	return cross(-normal, biTangent);
}

float3 CubeCoord(QuadGenerationConstants constants, float VerticesPerSide, uint3 id, int mod, float spacing)
{
	//32 : 1;
	//64 : 3;
	//128 : 7;
	//256 : 17;
	//512 : 41;
	//TODO modifier calculation. Seems to 1,3,7 are normal, but bigger... fail.
	float eastValue = (id.x - ((VerticesPerSide - mod) / 2.0)) * spacing;
	float northValue = (id.y - ((VerticesPerSide - mod) / 2.0)) * spacing;

	float3 cubeCoordEast = constants.cubeFaceEastDirection * eastValue;
    float3 cubeCoordNorth = constants.cubeFaceNorthDirection * northValue;

	float3 cubeCoord = cubeCoordEast + cubeCoordNorth + constants.patchCubeCenter;

	return cubeCoord;
}

float NoiseFunction(float3 coord)
{
	#ifdef defaultNoise
	float noise = RidgedMultifractalEroded(coord * 0.003 + Randomize, 1, 1, 4);
	#else
	float noise = HeightMapAsteroid(0.001 * coord, mainFreq, montesFreq, hillsFreq, hillsMagn, hillsFraction, craterOctaves, craterSqrtDensity, craterFreq, craterMagn);
	#endif
	
	return noise;
}

float4 ColorFunction(float3 coord, float height, float slope)
{
	#ifdef defaultNoise
	float3 color = float3(0.0, 0.0, 0.0);
	#else
	float3 color = ColorMapAsteroid(0.001 * coord, height, slope, colorDistFreq).xyz;
	#endif
	
	return float4(color, 1.0);
}

#pragma kernel HeightMain
[numthreads(32, 32, 1)]
void HeightMain (uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int outBuffOffset = id.x + id.y * nVertsPerSideWithBorder;

	float3 cubeCoord = CubeCoord(constants, nVertsPerSideWithBorder, id, 3, constants.spacing);

	float3 patchCenter = normalize(constants.patchCubeCenter) * constants.planetRadius;
	float3 patchNormalizedCoord = normalize(cubeCoord);

	float3 patchCoord =  constants.planetRadius * patchNormalizedCoord;
	float3 patchCoordCentered = patchCoord - patchCenter;
	float3 patchCubeCoordCentered = patchNormalizedCoord;
	float noise = NoiseFunction(patchCoord);

    float height = ((noise - (-1.0)) / (1.0 - (-1.0))) * constants.terrainMaxHeight;

	patchCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCentered += patchNormalizedCoord * height;

    float4 output = float4(patchCoordCentered.xyz, 0.0);
	float4 cubeOutput = float4(patchCubeCoordCentered.xyz, 0.0);

	patchPreOutput[outBuffOffset].noise = (noise - (-1.0)) / (1.0 - (-1.0));
	patchPreOutput[outBuffOffset].patchCenter = patchCenter;
	patchPreOutput[outBuffOffset].vcolor = float4(noise, noise, noise, 1.0);
    patchPreOutput[outBuffOffset].pos = output;
	patchPreOutput[outBuffOffset].cpos = cubeOutput;
}

#pragma kernel MeshDataMain
[numthreads(30, 30, 1)]
void MeshDataMain(uint3 id : SV_DispatchThreadID)
{
	int inBuffOffset = (id.x + 1) + (id.y + 1) * nVertsPerSideWithBorder;
    int outBuffOffset = id.x + id.y * nVerticesPerSide;

	patchOutput[outBuffOffset] = patchPreOutput[inBuffOffset];
}

#pragma kernel HeightSub
[numthreads(32, 32, 1)]
void HeightSub(uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int outBuffOffset = id.x + id.y * nVertsPerSideWithBorderSub;

	float3 cubeCoord = CubeCoord(constants, nVertsPerSideWithBorderSub, id, 17, constants.spacingsub);

	float3 patchCenter = normalize(constants.patchCubeCenter) * constants.planetRadius;
	float3 patchNormalizedCoord = normalize(cubeCoord);

	float3 patchCoord =  constants.planetRadius * patchNormalizedCoord;
	float3 patchCoordCentered = patchCoord - patchCenter;
	float3 patchCubeCoordCentered = patchNormalizedCoord;
	float noise = NoiseFunction(patchCoord);

    float height = ((noise - (-1.0)) / (1.0 - (-1.0))) * constants.terrainMaxHeight;

	patchCoordCentered += patchNormalizedCoord * height;
	patchCubeCoordCentered += patchNormalizedCoord * height;

    float4 output = float4(patchCoordCentered.xyz, 0.0);
	float4 cubeOutput = float4(patchCubeCoordCentered.xyz, 0.0);

	patchPreOutputSub[outBuffOffset].noise = (noise - (-1.0)) / (1.0 - (-1.0));
	patchPreOutputSub[outBuffOffset].patchCenter = patchCenter;
	patchPreOutputSub[outBuffOffset].vcolor = float4(noise, noise, noise, 1.0);
    patchPreOutputSub[outBuffOffset].pos = output;
	patchPreOutputSub[outBuffOffset].cpos = cubeOutput;
}

#pragma kernel TexturesSub
[numthreads(30, 30, 1)]
void TexturesSub(uint3 id : SV_DispatchThreadID)
{
	QuadGenerationConstants constants = quadGenerationConstants[0];

	int inBuffOffset = (id.x + 1) + (id.y + 1) * nVertsPerSideWithBorderSub;
    int outBuffOffset = id.x + id.y * nVerticesPerSideSub;
	
	float noise = patchPreOutputSub[inBuffOffset].noise;
	float3 patchCenter = patchPreOutputSub[inBuffOffset].patchCenter;
	float4 pos = patchPreOutputSub[inBuffOffset].pos;
	float4 cpos = patchPreOutputSub[inBuffOffset].cpos;

	float normalStrength = 0.5 / ((constants.lodLevel / 10.0 + 1.0) * (constants.lodLevel / 10.0 + 1.0));
	
	float tl = patchPreOutputSub[(id.x + 0) + (id.y + 0) * nVertsPerSideWithBorderSub].noise * normalStrength;
	float  l = patchPreOutputSub[(id.x + 0) + (id.y + 1) * nVertsPerSideWithBorderSub].noise * normalStrength;
	float bl = patchPreOutputSub[(id.x + 0) + (id.y + 2) * nVertsPerSideWithBorderSub].noise * normalStrength;
	float  t = patchPreOutputSub[(id.x + 1) + (id.y + 0) * nVertsPerSideWithBorderSub].noise * normalStrength;
	float  b = patchPreOutputSub[(id.x + 1) + (id.y + 2) * nVertsPerSideWithBorderSub].noise * normalStrength;
	float tr = patchPreOutputSub[(id.x + 2) + (id.y + 0) * nVertsPerSideWithBorderSub].noise * normalStrength;
	float  r = patchPreOutputSub[(id.x + 2) + (id.y + 1) * nVertsPerSideWithBorderSub].noise * normalStrength;
	float br = patchPreOutputSub[(id.x + 2) + (id.y + 2) * nVertsPerSideWithBorderSub].noise * normalStrength;

	/*
	float tl;
	float  l;
	float bl;
	float  t;
	float  b;
	float tr;
	float  r;
	float br;
		
	if(constants.orientation == 0 || constants.orientation == 1) //Top
	{
		tl = patchPreOutputSub[(id.x + 0) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
		 l = patchPreOutputSub[(id.x + 0) + (id.y + 1) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
		bl = patchPreOutputSub[(id.x + 0) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
		 t = patchPreOutputSub[(id.x + 1) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
		 b = patchPreOutputSub[(id.x + 1) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
		tr = patchPreOutputSub[(id.x + 2) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
		 r = patchPreOutputSub[(id.x + 2) + (id.y + 1) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
		br = patchPreOutputSub[(id.x + 2) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.y * constants.lodLevel;
	}
	else if(constants.orientation == 2 || constants.orientation == 3)
	{
		tl = -patchPreOutputSub[(id.x + 0) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
		 l = -patchPreOutputSub[(id.x + 0) + (id.y + 1) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
		bl = -patchPreOutputSub[(id.x + 0) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
		 t = -patchPreOutputSub[(id.x + 1) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
		 b = -patchPreOutputSub[(id.x + 1) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
		tr = -patchPreOutputSub[(id.x + 2) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
		 r = -patchPreOutputSub[(id.x + 2) + (id.y + 1) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
		br = -patchPreOutputSub[(id.x + 2) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.x * constants.lodLevel;
	}
	else
	{
		tl = patchPreOutputSub[(id.x + 0) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
		 l = patchPreOutputSub[(id.x + 0) + (id.y + 1) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
		bl = patchPreOutputSub[(id.x + 0) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
		 t = patchPreOutputSub[(id.x + 1) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
		 b = patchPreOutputSub[(id.x + 1) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
		tr = patchPreOutputSub[(id.x + 2) + (id.y + 0) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
		 r = patchPreOutputSub[(id.x + 2) + (id.y + 1) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
		br = patchPreOutputSub[(id.x + 2) + (id.y + 2) * nVertsPerSideWithBorderSub].cpos.z * constants.lodLevel;
	}
	*/

	float left  = patchPreOutputSub[(id.x + 0) + (id.y + 1) * nVertsPerSideWithBorderSub].noise * constants.lodLevel;
	float right = patchPreOutputSub[(id.x + 2) + (id.y + 1) * nVertsPerSideWithBorderSub].noise * constants.lodLevel;
	float up    = patchPreOutputSub[(id.x + 1) + (id.y + 0) * nVertsPerSideWithBorderSub].noise * constants.lodLevel;
	float down  = patchPreOutputSub[(id.x + 1) + (id.y + 2) * nVertsPerSideWithBorderSub].noise * constants.lodLevel;

	float xdeltaSlope = ((left - right) + 1.0) * 0.5;
	float ydeltaSlope = ((up - down) + 1.0) * 0.5;
	float zdeltaSlope = ((right - left) + 1.0) * 0.5;
	float wdeltaSlope = ((up - down) + 1.0) * 0.5;

	float3 xnormalSlope = float3(xdeltaSlope, ydeltaSlope, 1.0);
	float3 ynormalSlope = float3(ydeltaSlope, xdeltaSlope, 1.0);
	float3 znormalSlope = float3(zdeltaSlope, wdeltaSlope, 1.0);
	float3 wnormalSlope = float3(wdeltaSlope, zdeltaSlope, 1.0);

	float xdelta = tr + 2.0 * r + br - tl - 2.0 * l - bl;
	float ydelta = bl + 2.0 * b + br - tl - 2.0 * t - tr;

	float3 xnormal = normalize(float3(xdelta, ydelta, 2.0 * normalStrength));
	float3 ynormal = normalize(float3(ydelta, xdelta, 2.0 * normalStrength));

	float3 no = xnormal;
	float3 ta = FindTangent(no, 0.01, float3(0.0, 0.0, 0.0));
	float3 bi = FindBiTangent(no, 0.01, float3(0.0, 0.0, 0.0));

	float3x3 tbn = float3x3(ta, bi, no);

	float3 normal = mul(no, tbn);
	
	float xslope = 0.5 / max(dot(xnormalSlope, float3(0.0, 1.0, 0.0)), 0.001);
	float yslope = 0.5 / max(dot(ynormalSlope, float3(0.0, 1.0, 0.0)), 0.001);
	float zslope = 0.5 / max(dot(znormalSlope, float3(0.0, 1.0, 0.0)), 0.001);
	float wslope = 0.5 / max(dot(wnormalSlope, float3(0.0, 1.0, 0.0)), 0.001);

	float slope = min(min(xslope, yslope), min(zslope, wslope));

	float4 color = ColorFunction(cpos.xyz, noise, slope);
	float4 normalColor = float4(normal, slope);
	float4 heightColor = float4(color.xyz, noise);
	
	Normal[id.yx] = normalColor;
	Height[id.yx] = heightColor;
}

#pragma kernel Transfer
[numthreads(30, 30, 1)]
void Transfer(uint3 id : SV_DispatchThreadID)
{
	int inBuffOffset = (id.x + 1) + (id.y + 1) * nVertsPerSideWithBorder;
    int outBuffOffset = id.x + id.y * nVerticesPerSide;

	patchOutput[outBuffOffset] = patchPreOutput[inBuffOffset];
}