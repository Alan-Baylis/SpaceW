using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace Proland
{
	/*
	 * A manger to organise what order update functions are called, the running of tasks and the drawing of the terrain.
	 * Provides a location for common settings and allows the nodes to access each other.
	 * Also sets uniforms that are considered global.
	 * Must have a scheduler script attached to the same gameobject
	 * 
	 */
	public class Manager : MonoBehaviour 
	{
		public enum DEFORM { PLANE, SPHERE };

		[SerializeField]
		ComputeShader m_writeData;

		[SerializeField]
		ComputeShader m_readData;

		[SerializeField]
		int m_gridResolution = 25;

		[SerializeField]
		float m_HDRExposure = 0.2f;

		//If the world is a flat plane or a sphere
		[SerializeField]
		DEFORM m_deformType = DEFORM.PLANE;

		[SerializeField]
		float m_radius = 6360000.0f;

		Schedular m_schedular;

		OceanNode m_oceanNode;
		SkyNode m_skyNode;
		SunNode m_sunNode;
		PlantsNode m_plantsNode;
		TerrainNode[] m_terrainNodes;
		Controller m_controller;
		List<TileSampler> m_samplers;
		Mesh m_quadMesh;
		MaterialPropertyBlock m_propertyBlock;
		Vector3 m_origin;

		public int GetGridResolution() {
			return m_gridResolution;
		}
		
		public bool IsDeformed() {
			return (m_deformType == DEFORM.SPHERE);
		}
		
		public float GetRadius() {
			return m_radius;
		}

		public Schedular GetSchedular() {
			return m_schedular;
		}
		
		public ComputeShader GetWriteData() {
			return m_writeData;
		}
		
		public ComputeShader GetReadData() {
			return m_readData;
		}
		
		public SkyNode GetSkyNode() {
			return m_skyNode;
		}
		
		public SunNode GetSunNode() {
			return m_sunNode;
		}
		
		public OceanNode GetOceanNode() {
			return m_oceanNode;
		}

		public PlantsNode GetPlantsNode() {
			return m_plantsNode;
		}

		public Controller GetController() {
			return m_controller;
		}
	
		// Use this for initialization
		void Awake() 
		{

			if(IsDeformed())
				m_origin = Vector3.zero;
			else
				m_origin = new Vector3(0.0f, 0.0f, m_radius);

			m_schedular = GetComponent<Schedular>();
			m_controller = GetComponentInChildren<Controller>();

			//if planet view is being use set the radius
			if( m_controller.GetView() is PlanetView)
				((PlanetView)m_controller.GetView()).SetRadius(m_radius);

			//Get the nodes that are children of the manager
			m_oceanNode = GetComponentInChildren<OceanNode>();
			m_skyNode = GetComponentInChildren<SkyNode>();
			m_sunNode = GetComponentInChildren<SunNode>();
			m_plantsNode = GetComponentInChildren<PlantsNode>();
			m_terrainNodes = GetComponentsInChildren<TerrainNode>();

			m_samplers = new List<TileSampler>(GetComponentsInChildren<TileSampler>());
			m_samplers.Sort(new TileSampler.Sort());

			m_propertyBlock = new MaterialPropertyBlock();
			//make the mesh used to draw the terrain quads
			m_quadMesh = MeshFactory.MakePlane(m_gridResolution,m_gridResolution);
			m_quadMesh.bounds = new Bounds(Vector3.zero, new Vector3(1e8f, 1e8f, 1e8f));
		}

		public void SetUniforms(Material mat)
		{
			//Sets uniforms that this or other gameobjects may need
			if(mat == null) return;

			mat.SetMatrix("_Globals_WorldToCamera", m_controller.GetView().GetWorldToCamera().ToMatrix4x4());
			mat.SetMatrix("_Globals_CameraToWorld", m_controller.GetView().GetCameraToWorld().ToMatrix4x4() );
			mat.SetMatrix("_Globals_CameraToScreen", m_controller.GetView().GetCameraToScreen().ToMatrix4x4());
			mat.SetMatrix("_Globals_ScreenToCamera", m_controller.GetView().GetScreenToCamera().ToMatrix4x4());
			mat.SetVector("_Globals_WorldCameraPos", m_controller.GetView().GetWorldCameraPos().ToVector3());
			mat.SetVector("_Globals_Origin", m_origin);
			mat.SetFloat("_Exposure", m_HDRExposure);

		}
		
		// Update is called once per frame
		void Update () 
		{

			//Update the sky, sun and controller. These node are presumed to always be present
			m_controller.UpdateController();
			m_sunNode.UpdateNode();
			m_skyNode.UpdateNode();

			//Uppdate ocean if used
			if(m_oceanNode != null)
				m_oceanNode.UpdateNode();

			//Update all the terrain nodes used and active
			foreach(TerrainNode node in m_terrainNodes)
			{
				if(node.gameObject.activeInHierarchy) 
					node.UpdateNode();
			}

			//Update the plants node if used
			if(m_plantsNode != null)
				m_plantsNode.UpdateNode();

			//Update all the samplers used and active
			foreach(TileSampler sampler in m_samplers)
			{
				if(sampler.gameObject.activeInHierarchy)
					sampler.UpdateSampler();
			}

			//Run any tasks generated by updating the samplers
			m_schedular.Run();

			//Draw the terrain quads of each terrain node if active
			foreach(TerrainNode node in m_terrainNodes)
			{
				if(node.gameObject.activeInHierarchy)
					DrawTerrain(node);
			}

		}

		void DrawTerrain(TerrainNode node)
		{
			//Get all the samplers attached to the terrain node. The samples contain the data need to draw the quad
			TileSampler[] allSamplers = node.transform.GetComponentsInChildren<TileSampler>();
			List<TileSampler> samplers = new List<TileSampler>();
			//Only use sample if enabled
			foreach(TileSampler sampler in allSamplers)
			{
				if(sampler.enabled && sampler.GetStoreLeaf())
					samplers.Add(sampler);
			}

			if(samplers.Count == 0) return;

			//Find all the quads in the terrain node that need to be drawn
			FindDrawableQuads(node.GetRoot(), samplers);
			//The draw them
			DrawQuad(node, node.GetRoot(), samplers);

		}

		/*
		 * Find all the quads in a terrain that need to be drawn. If a quad is a leaf and is visible it should
		 * be drawn. If that quads tile is not ready the first ready parent is drawn
		 * NOTE - because of the current set up all task are run on the frame they are generated so 
		 * the leaf quads will always have tiles that are ready to be drawn
		 */
		void FindDrawableQuads(TerrainQuad quad, List<TileSampler> samplers)
		{
			quad.SetDrawable(false);
			
			if (!quad.IsVisible()) {
				quad.SetDrawable(true);
				return;
			}
			
			if (quad.IsLeaf()) 
			{
				for ( int i = 0; i < samplers.Count; ++i)
				{
					TileProducer p = samplers[i].GetProducer();
					int l = quad.GetLevel();
					int tx = quad.GetTX();
					int ty = quad.GetTY();

					if (p.HasTile(l, tx, ty) && p.FindTile(l, tx, ty, false, true) == null) {
						return;
					}
				}
			} 
			else 
			{
				int nDrawable = 0;
				for (int i = 0; i < 4; ++i) 
				{
					FindDrawableQuads(quad.GetChild(i), samplers);
					if (quad.GetChild(i).GetDrawable()) {
						++nDrawable;
					}
				}

				if (nDrawable < 4) 
				{
					for (int i = 0; i < samplers.Count; ++i) 
					{
						TileProducer p = samplers[i].GetProducer();
						int l = quad.GetLevel();
						int tx = quad.GetTX();
						int ty = quad.GetTY();
						
						if (p.HasTile(l, tx, ty) && p.FindTile(l, tx, ty, false, true) == null) {
							return;
						}
					}
				}
			}
			
			quad.SetDrawable(true);
		}

		void DrawQuad(TerrainNode node, TerrainQuad quad, List<TileSampler> samplers)
		{
			if (!quad.IsVisible()) {
				return;
			}

			if (!quad.GetDrawable()) {
				return;
			}

			if (quad.IsLeaf()) 
			{
				m_propertyBlock.Clear();

				for (int i = 0; i < samplers.Count; ++i) {
					//Set the unifroms needed to draw the texture for this sampler
					samplers[i].SetTile(m_propertyBlock, quad.GetLevel(), quad.GetTX(), quad.GetTY());
				}

				//Set the uniforms unique to each quad
				node.SetPerQuadUniforms(quad, m_propertyBlock);

				Graphics.DrawMesh(m_quadMesh, Matrix4x4.identity, node.GetMaterial(), 0, Camera.main, 0, m_propertyBlock);
			} 
			else 
			{
				//draw quads in a order based on distance to camera
				int[] order = new int[4];
				double ox = node.GetLocalCameraPos().x;
				double oy = node.GetLocalCameraPos().y;
				
				double cx = quad.GetOX() + quad.GetLength() / 2.0;
				double cy = quad.GetOY() + quad.GetLength() / 2.0;

				if (oy < cy) 
				{
					if (ox < cx) {
						order[0] = 0;
						order[1] = 1;
						order[2] = 2;
						order[3] = 3;
					} else {
						order[0] = 1;
						order[1] = 0;
						order[2] = 3;
						order[3] = 2;
					}
				} 
				else 
				{
					if (ox < cx) {
						order[0] = 2;
						order[1] = 0;
						order[2] = 3;
						order[3] = 1;
					} else {
						order[0] = 3;
						order[1] = 1;
						order[2] = 2;
						order[3] = 0;
					}
				}
				
				int done = 0;
				for (int i = 0; i < 4; ++i) 
				{
					if (quad.GetChild(order[i]).GetVisible() == Frustum.VISIBILTY.INVISIBLE) {
						done |= (1 << order[i]);
					} 
					else if (quad.GetChild(order[i]).GetDrawable()) {
						DrawQuad(node, quad.GetChild(order[i]), samplers);
						done |= (1 << order[i]);
					}
				}

				if (done < 15) 
				{
					//If the a leaf quad needs to be drawn but its tiles are not ready then this 
					//will draw the next parent tile instead that is ready.
					//Because of the current set up all tiles always have there tasks run on the frame they are generated
					//so this section of code is never reached

					m_propertyBlock.Clear();
					
					for (int i = 0; i < samplers.Count; ++i) {
						//Set the unifroms needed to draw the texture for this sampler
						samplers[i].SetTile(m_propertyBlock, quad.GetLevel(), quad.GetTX(), quad.GetTY());
					}
					
					//Set the uniforms unique to each quad
					node.SetPerQuadUniforms(quad, m_propertyBlock);
					//TODO - use mesh of appropriate resolution for non-leaf quads
					Graphics.DrawMesh(m_quadMesh, Matrix4x4.identity, node.GetMaterial(), 0, Camera.main, 0, m_propertyBlock);
				}
			}
		}
	}
}











































